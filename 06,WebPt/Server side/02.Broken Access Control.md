Broken access control is ==a security vulnerability where users can access data or perform actions beyond their authorized permissions==. This occurs when an application fails to enforce rules that restrict what an authenticated user can do, allowing attackers to view sensitive data, modify records, or escalate their privileges.

Common examples include forcing a URL to change from `/user/profile/101` to `/user/profile/102` to view another user's profile

```
┌─────────────────────────────────────────────────────────────┐
│                    ACCESS CONTROL                           │
├─────────────────────────────────────────────────────────────┤
│  Authentication  →  "Who are you?"                          │
│  Authorization   →  "What can you do?"                      │
│  Access Control  →  "Enforcing these rules"                 │
└─────────────────────────────────────────────────────────────┘
```
## What it is

- **Authorization failure**: It's a failure of the "access control" or "authorization" part of a system, which is responsible for governing permissions, not the initial "authentication" which confirms identity.

- **Principle of Least Privilege violation**: This vulnerability violates the [principle of least privilege](https://www.google.com/search?client=firefox-b-d&q=principle+of+least+privilege&ved=2ahUKEwjR2IDtlaSRAxUUWHADHYFYEqcQgK4QegYIAQgAEAw), which states that users should only have the minimum access necessary to perform their jobs.
### [^1]The Principle of Least Privilege (PoLP)
[^1]: This is the "Golden Rule" of Blue Team defense.
	
	- **Definition:** A user, program, or process should have **only** the bare minimum privileges necessary to perform its function. nothing more.
	    
	- **The Violation:** Broken Access Control happens when developers are "generous" with permissions.
	    
	    - _Example:_ A standard user needs to update their profile picture. The developer gives the API permission to update the _entire_ user object (including the `role` field). This violates PoLP.
	        
	- **Blue Team Fix:** The default setting for any access control list (ACL) should be **"Deny All"**. You only explicitly "Allow" what is strictly needed.

## Outcomes 
#### A. Vertical Privilege Escalation

This is when a lower-privileged user (like a standard customer) gains access to functions reserved for higher-privileged users (like an Administrator).

- **Example:** A standard user accesses `https://website.com/admin` because the server doesn't check if the user is actually an admin.

#### B. Horizontal Privilege Escalation

This is when a user gains access to resources belonging to another user of the same level.

- **Example:** User A (ID: 101) changes a URL parameter to ID: 102 and views User B's private messages.

## Types of Broken Access Control

```
┌──────────────────────────────────────────────────────────────────────────┐
│                      A01:2025 - BROKEN ACCESS CONTROL                    │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   VULNERABILITY TYPES                         OUTCOMES                   │
│   (What is broken)                            (What attacker achieves)   │
│                                                                          │
│   ┌─────────────────────────────┐      ┌───────────────────────────────┐ │
│   │                             │      │                               │ │
│   │ 1. IDOR                     │      │  • Horizontal Privilege       │ │
│   │                             │      │    Escalation                 │ │
│   │ 2. Forced Browsing          │      │    (User A → User B data)     │ │
│   │                             │      │                               │ │
│   │ 3. Path/Directory Traversal │      │  • Vertical Privilege         │ │
│   │                             │──────▶    Escalation                 │ │
│   │ 4. File Inclusion (LFI/RFI) │      │    (User → Admin)             │ │
│   │                             │      │                               │ │
│   │ x. Open Redirect            │      │  • Unauthorized Data Access   │ │
│   │                             │      │                               │ │
│   │ 5. Missing Function-Level   │      │  • Unauthorized File Access   │ │
│   │    Access Control           │      │                               │ │
│   │                             │      │  • Unauthorized Actions       │ │
│   │ 6. WebSocket Auth Bypass    │      │                               │ │
│   │                             │      │  • Data Modification/Deletion │ │
│   │ 7. CSRF                     │      │                               │ │
│   │                             │      │  • Account Takeover           │ │
│   │ 8. CORS Misconfiguration    │      │                               │ │
│   │                             │      └───────────────────────────────┘ │
│   └─────────────────────────────┘                                        │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

| #   | Vulnerability Type        | Possible Outcomes              |
| --- | ------------------------- | ------------------------------ |
| 1   | IDOR                      | Horizontal/Vertical Escalation |
| 2   | Forced Browsing           | Vertical Escalation            |
| 3   | Path/Directory Traversal  | Unauthorized File Access       |
| 4   | File Inclusion (LFI/RFI)  | File Access, Code Execution    |
| 5   | Open Redirect             | Phishing, Token Theft          |
| 6   | Missing Function-Level AC | Vertical Escalation            |
| 7   | WebSocket Auth Bypass     | Unauthorized Actions           |
| 8   | CSRF                      | Unauthorized Actions           |
| 9   | CORS Misconfiguration     | Cross-Origin Data Theft        |
|     |                           |                                |
```
CSRF
 ├─ Root cause: Request integrity failure
 ├─ Victim is authorized
 ├─ User intent is missing
 └─ Outcome: Unauthorized action

OWASP groups by outcome → A01
Security engineers classify by cause → NOT access control

```

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    TECHNIQUES → EXPLOIT → VULNERABILITY                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   TECHNIQUE                        EXPLOITS                             │
│                                                                         │
│   Parameter Manipulation    ────▶  IDOR                                 │
│   (/user?id=123 → id=456)          (Access other user's data)           │
│                                                                         │
│   Cookie Manipulation       ────▶  IDOR / Missing Function-Level AC     │
│   (user_id=5 → user_id=6)          (Session-based access bypass)        │
│                                                                         │
│   JWT/Token Manipulation    ────▶  IDOR / Missing Function-Level AC     │
│   (role:user → role:admin)         (Token-based access bypass)          │
│                                                                         │
│   HTTP Method Tampering     ────▶  Missing Function-Level AC            │
│   (GET blocked, try POST)          (Method-based restrictions bypass)   │
│                                                                         │
│   Header/Metadata Manip.    ────▶  Forced Browsing / Function-Level AC  │
│   (X-Original-URL: /admin)         (Header-based access bypass)         │
│                                                                         │
│   CORS Misconfiguration     ────▶  Unauthorized Cross-Origin Access     │
│   (Origin: evil.com allowed)       (Could be considered a TYPE)         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

| Vulnerability Type     | What's Manipulated | Unauthorized Access To |
| ---------------------- | ------------------ | ---------------------- |
| IDOR                   | Object IDs         | Other users' data      |
| Forced Browsing        | URL paths          | Hidden pages/APIs      |
| Path Traversal         | File paths (`../`) | Server files           |
| JWT Tampering          | Token claims       | Higher privileges      |
| Parameter Manipulation | Request params     | Restricted functions   |
| Cookie Manipulation    | Cookie values      | Other sessions/roles   |

# 1. IDOR(Insecure Direct Object Reference)(server side)

- IDOR occurs when an application provides direct access to objects based on user-supplied input. As a result of this vulnerability, attackers can bypass authorization and access resources in the system directly, for example database records or+ files.

- ==Attacker accesses unauthorized resources by manipulating object identifiers(ID of user,filename,etc).==

- Application exposes internal object references (IDs, filenames, keys) that attacker can manipulate to access other users' data. 


```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              IDOR TYPES                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. URL-Based IDOR                                                         │
│      ├── /api/user/123/profile                                              │
│      ├── /order/456/details                                                 │
│      ├── /invoice/789/download                                              │
│      └── Test: Change 123 → 456 in URL path                                 │
│                                                                             │
│   2. Body Parameter IDOR                                                    │
│      ├── JSON:  { "user_id": 123, "action": "view" }                        │
│      ├── Form:  user_id=123&action=update                                   │
│      ├── XML:   <userId>123</userId>                                        │
│      └── Test: Modify ID value in request body                              │
│                                                                             │
│   3. Cookie-Based IDOR                                                      │
│      ├── Plain:   Cookie: user_id=123                                       │
│      ├── Encoded: Cookie: user_id=MTIz (Base64)                             │
│      ├── JSON:    Cookie: user={"id":123}                                   │
│      └── Test: Edit cookie value in browser/Burp                            │
│                                                                             │
│   4. Header-Based IDOR                                                      │
│      ├── X-User-ID: 123                                                     │
│      ├── X-Account-ID: ACC001                                               │
│      ├── X-Customer-ID: 456                                                 │
│      └── Test: Modify or add custom headers                                 │
│                                                                             │
│   5. File Reference IDOR                                                    │
│      ├── /download?file=user_123_report.pdf                                 │
│      ├── /docs?name=invoice_456.pdf                                         │
│      ├── /export?id=backup_789.zip                                          │
│      └── Test: Guess other users' filenames                                 │
│                                                                             │
│   6. Query Parameter IDOR                                                   │
│      ├── /profile?id=123                                                    │
│      ├── /account?user=456&action=view                                      │
│      ├── /api/data?userId=789                                               │
│      └── Test: Change parameter value in URL                                │
│                                                                             │
│   7. Hash/Encoded IDOR                                                      │
│      ├── /user/MTIz (Base64 of "123")                                       │
│      ├── /doc/202cb962ac59... (MD5 of "123")                                │
│      ├── /profile/7b226964223a3132337d (Hex encoded)                        │
│      └── Test: Decode → Modify → Re-encode                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│                  WHERE TO FIND IDOR                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   URL Parameters:                                               │
│   ├── /user/123/profile                                         │
│   ├── /order/456/details                                        │
│   ├── /invoice/789/download                                     │
│   └── /message/101/view                                         │
│                                                                 │
│   Query Parameters:                                             │
│   ├── ?user_id=123                                              │
│   ├── ?account=456                                              │
│   ├── ?doc_id=789                                               │
│   └── ?transaction=101                                          │
│                                                                 │
│   Request Body:                                                 │
│   ├── { "id": 123 }                                             │
│   ├── { "user_id": 456 }                                        │
│   └── { "order_id": 789 }                                       │
│                                                                 │
│   Headers:                                                      │
│   ├── X-User-ID: 123                                            │
│   └── X-Account-ID: 456                                         │
│                                                                 │
│   Cookies:                                                      │
│   └── user_id=123; account=456                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Real Life Testing
1. **Create Two Accounts:** Create User A (Attacker) and User B (Victim).
2. **Identify IDs:** Look for predictable IDs in requests (e.g., user_id=1001, invoice_id=55).
3. **Capture Request:** Log in as User A and perform an action (e.g., View Profile).
4. **Swap IDs:** Send the request to Repeater and change the ID to User B's ID.
**Analyse Response:**
- 200 OK + Data = Vulnerable
- 403 Forbidden = Secure (usually)
- 401 Unauthorized = Not logged in
#### Example 1: Bank Account Access
```
# Normal Request (User's own account)
GET /api/account/1001/balance
Authorization: Bearer <token>

Response: { "balance": "$5,000" }

# IDOR Attack (Other user's account)
GET /api/account/1002/balance
Authorization: Bearer <token>

Response: { "balance": "$50,000" }  # Unauthorized access!
```

#### Example 2: Password Reset IDOR
```
# Normal Request
POST /api/reset-password
{ "user_id": 123, "new_password": "newpass123" }

# IDOR Attack
POST /api/reset-password
{ "user_id": 456, "new_password": "hacked123" }  # Reset other user's password!
```

#### Real-World IDOR Examples

| Company       | What Happened        | Impact                     |
| :------------ | :------------------- | :------------------------- |
| **Facebook**  | IDOR in photo albums | View private photos        |
| **Uber**      | IDOR in trip history | Access other riders' trips |
| **Shopify**   | IDOR in admin panel  | Access other stores' data  |
| **Instagram** | IDOR in media ID     | Delete any user's photos   |
| **Twitter**   | IDOR in DMs          | Read private messages      |

**ID Manipulation Techniques**
```
# Sequential IDs
/user/100 → /user/101, /user/102, /user/99

# UUID Guessing (if predictable)
/user/550e8400-e29b-41d4-a716-446655440000
→ /user/550e8400-e29b-41d4-a716-446655440001

# Encoded IDs
/user/MTIz (base64 of "123") → /user/NDU2 (base64 of "456")

# Hashed IDs (if weak)
/user/202cb962ac59075b964b07152d234b70 (MD5 of "123")
→ /user/250cf8b51c773f3f8dc8b4be867a9a02 (MD5 of "456")

# Wrapped IDs
/user/{"id":123} → /user/{"id":456}
```

## Mitigation
```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          IDOR MITIGATIONS                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. Verify Ownership on Every Request                                      │
│      ├── Always check if user owns the resource                             │
│      ├── Don't trust client-provided IDs                                    │
│      └── Use server-side session for user identity                          │
│                                                                             │
│   2. Use Indirect Object References                                         │
│      ├── Map real IDs to random tokens per session                          │
│      ├── User sees: abc123xyz                                               │
│      └── Server resolves: abc123xyz → real ID 456                           │
│                                                                             │
│   3. Use UUIDs Instead of Sequential IDs                                    │
│      ├── Bad:  /user/1, /user/2, /user/3                                    │
│      └── Good: /user/550e8400-e29b-41d4-a716-446655440000                   │
│                                                                             │
│   4. Implement Proper Access Control                                        │
│      ├── Role-Based Access Control (RBAC)                                   │
│      ├── Attribute-Based Access Control (ABAC)                              │
│      └── Check permissions at every endpoint                                │
│                                                                             │
│   5. Validate at Database Query Level                                       │
│      ├── Bad:  SELECT * FROM orders WHERE id = ?                            │
│      └── Good: SELECT * FROM orders WHERE id = ? AND user_id = ?            │
│                                                                             │
│   6. Logging & Monitoring                                                   │
│      ├── Log all access attempts                                            │
│      ├── Alert on suspicious patterns                                       │
│      └── Monitor for enumeration attacks                                    │
│                                                                             │
│   7. Rate Limiting                                                          │
│      ├── Limit requests per user/IP                                         │
│      └── Prevents mass ID enumeration                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**example:**
```
// ❌ VULNERABLE - No ownership check
app.get('/api/order/:id', (req, res) => {
    const order = db.query('SELECT * FROM orders WHERE id = ?', [req.params.id]);
    res.json(order);
});

// ✅ SECURE - Ownership verification
app.get('/api/order/:id', authenticateToken, (req, res) => {
    const order = db.query(
        'SELECT * FROM orders WHERE id = ? AND user_id = ?', 
        [req.params.id, req.user.id]  // Added user_id check
    );
    
    if (!order) {
        return res.status(404).json({ error: 'Not found' });
    }
    
    res.json(order);
});
```



# [[15.Forced Browsing (server side)]]



### 3. Mass Assignment (Auto-Binding)

**How it happens:** Modern coding frameworks (like NodeJS, Ruby on Rails, Java Spring) have a feature to make life easy: they automatically take **all** data sent by a user (JSON) and stuff it into a Database Object.

- **The Technical Failure:** The user object in the database might have sensitive fields like `is_admin`, `balance`, or `role`. The sign-up form only asks for `username` and `password`, but the framework is listening for _anything_.
    
- **The Attack:**
    
    1. **Normal Request:** `{"username": "test", "password": "123"}`
        
    2. **Attacker's Request:** The attacker adds a field they guessed. `{"username": "test", "password": "123", "is_admin": true}`
        
    3. **Result:** The code says "Update the User Object with this JSON." It blindly updates the `is_admin` field to true because the developer didn't blacklist that field.
        

### 4. Improper Configuration

**How it happens:** This is not a code error; it is a **deployment error**. The code might be secure, but the web server (Apache, Nginx, IIS) or Cloud Bucket (AWS S3) rules are weak.

- **The Technical Failure:** Leaving default settings active.
    
- **Common Examples:**
    
    - **Directory Listing:** If you go to `example.com/images/` and see a list of files instead of a webpage, that is a misconfiguration.
        
    - **Default Credentials:** Leaving the Tomcat Manager page active with `admin:admin`.
        
    - **HTTP Method Support:** Allowing `PUT` or `DELETE` methods on a server that should only allow `GET` and `POST`.
        
- **The Attack:** The attacker looks for known default files (like `/.git/config` or `/server-status`) or tries default passwords to gain control.

## HOW/WHY it happen

It happens because of a fundamental misunderstanding of **where** security checks should happen.

==In a secure system, the server checks its own **Database** to verify a user's role. In a vulnerable system, the server checks the **User's Browser (Client)** to verify the role.==

### 1. The Core Issue: HTTP is "Stateless"
When you visit a website, the server does not inherently remember who you are. To fix this, when you log in, the server gives your browser a "tag" (usually a Cookie or Token) to send back with every request.

### 2. The Developer's Mistake

A lazy or inexperienced developer tries to save server resources. Instead of checking the database every time you click a page (which takes time), they write the permission logic directly into the "tag" they gave you.

- **Secure Way:** The tag is just a random ID (`SessionID=XYZ`). The server looks up `XYZ` in its private database to see that you are a "User".
    
- **Vulnerable Way:** The tag actually contains the data (`Role=User`). The server just reads this tag to decide what you can do. ex= Role=ADMIN(attacker change user to admin).


### 3. The Attack Flow

- **Server Generation:** You log in. The server creates a cookie `{"username": "wiener", "admin": false}` and sends it to your browser.
    
- **Storage:** Your browser saves this cookie.
    
- **Interception:** You click "Admin Panel". Your browser prepares to send the request with the cookie `admin: false`.
    
    - _Here is where it happens:_ You pause the request in **Burp Suite**.
        
    - You edit the text to `admin: true`.
        
- **Server Processing:** The server receives the request.
    
    - The server's code says: _"Read the cookie. If 'admin' is true, show the panel."_
        
    - The server **does not** check the database. It blindly trusts the text inside the cookie you sent.
        
- **Execution:** Since the text now says `true`, the server executes the code to render the Admin Panel.


### Code Comparison

Vulnerable Code (What allows the attack):

```
# The server reads the role directly from the user's cookie
user_role = request.cookies.get('role') 

# IF the user sent a cookie saying they are admin...
if user_role == 'admin':
    show_admin_panel()  # ...The server obeys.
else:
    show_error("Access Denied")
```

Secure Code (What prevents the attack):

```
# The server reads a Session ID from the user
session_id = request.cookies.get('session_id')

# The server looks up the REAL role in its own Database
user = database.query("SELECT role FROM users WHERE session_id = ?", session_id)

# The server checks the database result, NOT the user input
if user.role == 'admin':
    show_admin_panel()
else:
    show_error("Access Denied")
```


## Potential impact

- **Sensitive data disclosure**: Attackers can access and steal confidential information, such as personal data, financial details, or proprietary information.
- **Unauthorized modification or deletion**: They can change or delete data that they are not authorized to access.
- **Privilege escalation**: A normal user can escalate their privileges to gain administrative access to the entire application.
- **Complete application takeover**: In severe cases, it can lead to a full takeover of the application.

```
HIGH PROBABILITY:
├── E-commerce sites (order/payment IDORs)
├── Healthcare portals (patient data)
├── SaaS platforms (multi-tenant issues)
├── Banking applications (transaction access)
├── Social media (private content access)
├── File sharing services
├── API endpoints (especially mobile app APIs)
└── Admin panels

COMMON VULNERABLE ENDPOINTS:
├── /api/v1/users/{id}
├── /account/settings
├── /orders/{order_id}
├── /download?file=
├── /admin/* (without proper checks)
├── /api/internal/*
└── /graphql (introspection enabled)
```