# Shared Preference

Shared Preferences is an Android API used to store small collections of primitive data (Booleans, floats, integers, longs, strings) in key-value pairs.

**The vulnerability exists when developers store sensitive information (PII, Passwords, API Tokens, Session IDs) in Shared Preferences without implementing encryption. If an attacker gains physical access to an unlocked device, uses a malicious app with root privileges, or dumps the filesystem, they can read this data in plain text.**

1. **Working:** The Android OS creates an ==XML== file in the app's private directory to store this data.
2. **Path:** These files are typically located at:
```
    /data/data/<package_name>/shared_prefs/<filename>.xml
```

**Vulnerability:** Developers often make the mistake of storing sensitive information (like passwords, API keys, or session tokens) in Shared Preferences in plain text (unencrypted). If an attacker gains access to the device (physically or via malware with root access), they can easily read these secrets.

#### Impact

**Account Takeover:** If an attacker extracts the session_token or plain text password, they can log in as the victim without needing to guess credentials.

**Privilege Escalation:** If the app stores user roles locally (e.g., <boolean name="is_admin" value="false" />), an attacker with a rooted device can simply edit the XML file to change "false" to "true" and gain administrative rights.

**Data Leakage:** Immediate exposure of PII (Personally Identifiable Information) or API Keys used to access third-party services.

## Beetle Bug APK Lab
##### Step 1: Input Data
Enter credentials:

    User: admin
    Pass: SuperSecret123


##### Step 2: Access Device Shell
Connect to the device using ADB from your host machine.

```Bash
adb shell
```

##### Step 3: Escalate Privileges
Switch to the root user to access the protected /data/ directory.

```BASH
su
# Prompt should change from $ to #
```

##### Step 4: Locate Application Package
Find the specific package name for Beetle Bug.

```BASH
pm list packages | grep beetle
# Output typically: com.beetlebug
```

##### Step 5: Navigate to Shared Prefs
Move to the application's data directory.

```BASH
cd /data/data/com.beetlebug/shared_prefs
ls -la
```
Look for .xml files (e.g., UserPrefs.xml or sp_info.xml).

##### Step 6: Extract Data
Read the content of the XML file.

```BASH
cat sp_info.xml
```

##### Result (Evidence)
```XML
<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<map>
    <string name="User">admin</string>
    <string name="Password">SuperSecret123</string>
</map>
```

#### Prevention/Mitigation

**Use EncryptedSharedPreferences:**
    Instead of the standard SharedPreferences, use the Android Jetpack Security library. This wraps the Shared Preferences class and automatically encrypts both the Keys and the Values using AES-256.
        Code: EncryptedSharedPreferences.create(...)
**Avoid Storing Credentials:**
    Never store raw passwords. If you must store authentication data, store a short-lived OAUTH Token (access token) instead of the user's password.
**Disable Backups:**
    In AndroidManifest.xml, set android:allowBackup="false". This prevents attackers from extracting the Shared Preferences XML file using the adb backup command (which does not require root).


# External Storage(SD Card)

In Android, file storage is divided into two main types:
1. **Internal Storage:** Private to the app. Other apps cannot access it (unless the device is rooted).
2. **External Storage:** Shared storage (e.g., /sdcard/). Historically, this space was used for photos, downloads, and documents.

 ##### **Vulnerability:**
 Files stored in External Storage are globally readable and globally writable by other applications that have the READ_EXTERNAL_STORAGE permission.
 
1. **The Risk:** If a legitimate banking app saves your statement to External Storage, a malicious "Flashlight" app installed on your phone can read that statement silently in the background and upload it to a hacker.
2. **Root requirement:** Unlike Lab 1 (Internal Storage), an attacker often does not need root access to exploit this. They just need a malicious app installed on the victim's phone.

**Attack:** A malicious app can scan the SD card for files containing "password", "config", or "token" and steal them or can send to an attacker.

#### Impact

**High-Risk Data Theft (No Root Required):** This is more dangerous than internal storage vulnerabilities because root access is not required. Any malicious app installed on the victim's phone (e.g., a fake flashlight app) with READ_EXTERNAL_STORAGE permission can silently steal these files.

**Data Integrity Attacks:** Since external storage is globally writable, a malicious app can modify the file. For example, if the app loads a config file from the SD card, malware could inject malicious URLs or code into that file, causing the legitimate app to execute it.

**Privacy Violation:** Photos, documents, or logs stored here persist even after the app is uninstalled (in many cases), leaving "digital trash" that can be analyzed later.

##### Step 1: Input Data
Enter dummy credentials:

    User: sdcard_user
    Pass: public123

##### Step 2: Access Device Shell
```bash
adb shell
```

##### Step 3: Navigate to External Storage
```bash
cd /sdcard/
```

##### Step 4: Locate the File
List the files to find the one created by the app. It is often created in the root of the SD card or inside a folder named BeetleBug.

```bash
ls -la
```

Look for a file named Data.txt, info.txt, or a folder named BeetleBug.

If you see a folder, enter it:
```bash
cd BeetleBug  # (Example folder name)
ls
```

##### Step 5: Extract Data
Read the content of the file.

```
cat Data.txt
```

##### Result
```
Username: sdcard_user
Password: public123
```
The credentials are stored in plain text in a globally accessible directory.

## Prevention/Mitigation

**Enforce Internal Storage:**
```
Always use Context.getFilesDir() or Context.getCacheDir(). This saves data to the /data/data/<package> directory, which is sandboxed by the OS and inaccessible to other apps.
```
**Encrypt File Content:**
    If business requirements force you to use External Storage (e.g., for a user to export a PDF), you must encrypt the file content before writing it to disk.
**Use Content Providers:**
    Instead of saving a file to the SD card to share it with another app, use a FileProvider. This grants temporary, secure access to a specific file in your internal storage to another specific app, without making it public.


# SQLite Storage
SQLite is the most common way Android apps store structured data (like contacts, message history, or product lists). It is a full-featured relational database contained in a single file.

**Location:** 
```
/data/data/<package_name>/databases/<name>.db
```

**Vulnerability:**
Just like Shared Preferences, developers often store sensitive data (credentials, credit card numbers, auth tokens) in these database tables without encryption.

***Apps use .db files to store structured data. These files are located in the app's private directory. While sandboxed from other apps, they are accessible to anyone with root access.***

**Risk:** If an attacker dumps the filesystem (via malware or physical access), they can open the database and read all rows in plain text

#### Impact

**Mass Data Exposure:** Unlike Shared Preferences (which usually store small keys), databases often hold the user's entire history (Chat logs, Transaction history, Contacts, Offline emails). A compromise here leads to a total loss of privacy.

**Forensic Recovery:** Even if a user deletes a message in the app, SQLite databases often leave "deleted" data in the file pages until a VACUUM command is run. An attacker can recover deleted messages from the .db file.

**SQL Injection Risks:** While this is a separate vulnerability, having an unencrypted database makes it easier for an attacker to analyze the schema (table names, column names) to craft specific SQL Injection attacks against the app.

##### Step 1: Input Data
Enter credentials:

    User: db_admin
    Pass: sql_pass_123

##### Step 2: Access the Shell
```
adb shell
su
```

##### Step 3: Navigate to Database Directory
Go to the Beetle Bug databases folder.

```
cd /data/data/com.beetlebug/databases
ls -la
```
You will see a file likely named beetlebug.db, user.db, or similar. (Sometimes there is a temporary file named .db-journal, ignore that).

##### Step 4: Open the Database
Use the sqlite3 tool to open the file.

```
sqlite3 beetlebug.db
```

##### Step 5: Enumerate Tables
Find out what tables exist in this database.
```
.tables
```

##### Step 6: Dump the Data
Query the table you found (e.g., users) to see the contents.
```
select * from users;
```

#### Result
```
1|db_admin|sql_pass_123
```
The ID is 1, Username is db_admin, and Password is sql_pass_123 (Plain Text).

### Prevention/Mitigation

**Implement SQLCipher:**
    This is the industry standard solution. It is an open-source extension to SQLite that provides transparent 256-bit AES encryption of database files.
        Even if the attacker steals the file, it is unreadable without the key.
**Use Realm with Encryption:**
    If using the Realm database instead of SQLite, enable the built-in encryption configuration: RealmConfiguration config = new RealmConfiguration.Builder().encryptionKey(key).build();.
**Hashing:**
    If storing passwords or PINs in a database is unavoidable (it should be avoided!), store the Salted Hash (e.g., Argon2, bcrypt) of the value, never the plain text.
**minimize Data Retention:**
    Don't store what you don't need. If the data is sensitive, consider clearing the database tables when the application is closed or the session ends.


# OWASP TOP 10:M9
### A. Shared Preferences / Plist (Plain Text)

Description: Storing sensitive key-value pairs (API tokens, boolean flags like is_admin, passwords) in unencrypted XML files.

Vulnerability: Anyone with root access (or physical access via backup extraction) can read the XML file.

### B. Unencrypted SQL Databases (SQLite / Realm)

Description: Storing user history, chat logs, or credentials in standard .db files without using encryption libraries (like SQLCipher).

Vulnerability: The database file can be pulled from the device and opened with any SQLite viewer to read all records.

### C. External Storage Usage (SD Card)

Description: Writing files to /sdcard/ or /storage/emulated/0/.

Vulnerability: This is "World Readable." Any other app installed on the user's phone (with simple storage permissions) can read this data. No root required.

### D. Caching of Sensitive Information (HTTP Cache)

Description: Networking libraries (like OkHttp, Retrofit, or Volley) automatically cache HTTP responses to speed up the app.

Vulnerability: If the API response contains PII (Personally Identifiable Information) or session tokens, these are saved in the cache folder in plain text.

### E. Keyboard Cache

Description: The Android keyboard "learns" words you type to offer predictive text.

Vulnerability: If the input field for a password or credit card is not flagged correctly, the keyboard dictionary stores the secret word. An attacker can type the first few letters, and the keyboard will "suggest" the full password.

### F. Application Background Screenshots

Description: When you minimize an app, Android takes a screenshot of the last state to show in the "Recent Apps" switcher.

Vulnerability: If the screen displayed a credit card number or a QR code when minimized, that image is stored unencrypted in the OS cache.

### G. Insecure Logs (Logcat / Log Files)

Description: Developers use Log.d() or write to local text files for debugging.

Vulnerability: Leaving these logs enabled in production means secrets (like "User logged in with token: XYZ") are written to the system log or a file on disk.

### H. Android Backups

Description: The android:allowBackup="true" flag in AndroidManifest.xml.

Vulnerability: This allows a user (or attacker with USB access) to copy the app's entire internal data sandbox to a computer using adb backup, bypassing the need for root access to read internal files.

```
┌─────────────────────────────────────────────────────────────┐
│              ALL M9 VULNERABILITIES                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1.  Shared Preferences (Plain Text)                        │
│  2.  SQLite Databases (Unencrypted)                         │
│  3.  External Storage (SD Card)                             │
│  4.  Internal Storage (Insecure Files)                      │
│  5.  Hardcoded Credentials                                  │
│  6.  Insecure Logging                                       │
│  7.  Clipboard Data                                         │
│  8.  Cache Files                                            │
│  9.  Backup Vulnerabilities                                 │
│  10. Keyboard Cache                                         │
│  11. WebView Data                                           │
│  12. Third-Party Keyboard Data                              │
│  13. Screenshot/Screen Recording                            │
│  14. Memory/RAM Data                                        │
│  15. Firebase/Cloud Misconfiguration                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```