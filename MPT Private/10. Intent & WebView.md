Intent is a messaging object used for communication between Android components. It requests an action from another app component like starting an activity, service, or delivering a broadcast.  

In the Android world, components (Activities, Services) don't talk to each other directly. Instead, they create an Intent (an envelope), put some instructions and data inside it, and hand it to the Android OS. The OS then delivers that message to the correct destination.

It is used for:
- **Starting an Activity:** (e.g., clicking a button to go from Screen A to Screen B).
- **Starting a Service:** (e.g., telling the app to start downloading a file in the background).
- **Broadcasting a Message:** (e.g., The system telling all apps: "The battery is low" or "WiFi is connected").

Intents are critical attack vectors for inter-process communication vulnerabilities.

```
//example of an intent.
 am start -n app.beetlebug.ctf/.b33tleAdministrator
```
## Types of Intents
#### 1.Explicit Intent

You specify exactly which component should receive the intent by providing the full class name.
```JAVA
Intent intent = new Intent(this, LoginActivity.class);
startActivity(intent);
```

Here the app knows exactly where to send the intent. Only LoginActivity will receive it. This is secure because no other app can intercept.

#### Implicit Intent

You only specify what action you want. Any app that can handle this action can respond.
```java
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.setData(Uri.parse("https://example.com"));
startActivity(intent);
```

**Here multiple browsers can respond like Chrome, Firefox, or a malicious app pretending to be a browser. This is where security problems begin.**

#### Components of Intent

1. **Action**
Defines what operation to perform.
```
intent.setAction("android.intent.action.VIEW");
intent.setAction("android.intent.action.SEND");
intent.setAction("com.target.app.TRANSFER_MONEY");
```

2. **Data**
Contains URI that the action operates on.
```
intent.setData(Uri.parse("content://contacts/1"));
intent.setData(Uri.parse("file:///sdcard/secret.pdf"));
intent.setData(Uri.parse("myapp://payment?amount=100"));
```

3. **Extras**
Key-value pairs carrying additional data.
```
intent.putExtra("username", "admin");
intent.putExtra("amount", 10000);
intent.putExtra("isAdmin", true);
```

4. **Flags**
Modify how intent is handled.
```
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
```
## How Components Receive Intents
In AndroidManifest.xml, components declare what intents they can handle using intent-filter:

```
<activity android:name=".ShareActivity"
          android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:mimeType="text/plain"/>
    </intent-filter>
</activity>
```

This ShareActivity says it can handle SEND action for plain text. When any app sends text using implicit intent, this activity can receive it.

#### Intent Filter
Intent Filter tells Android what types of intents a component can handle. When an app sends an implicit intent, Android looks at all intent filters to find matching components.
## Finding Vulnerable Components
Step 1: Decompile APK
use JDX
Step 2: Search for Exported Components
```
grep -r "exported=\"true\"" AndroidManifest.xml
```

Step 3: Search for Intent Filters
```
grep -r "intent-filter" AndroidManifest.xml
```

Step 4: Search for Deep Link Schemes
```
grep -r "android:scheme" AndroidManifest.xml
```

Step 5: List Attack Surface Using Drozer
```
drozer console connect
run app.package.attacksurface com.target.app
```

output:
Attack Surface:
```
  4 activities exported
  2 broadcast receivers exported
  1 content providers exported
  1 services exported
```

Step 6: Get Details of Exported Activities
```
run app.activity.info -a com.target.app
```

## Vulnerabilities in Intents
1: Exported Activity Without Protection
2: Sensitive Data in Extras Without Validation
3: Intent Hijacking
4: Unvalidated Deep Links
5: Path Traversal via Intent
6: SQL Injection via Intent
7: Pending Intent Vulnerability
8: Broadcast Injection

## Intent Redirection 
In Android, some activities are exported (public) and some are non-exported (private). Non-exported activities cannot be accessed by other apps directly.

Intent Redirection happens when:
- App has an exported activity that accepts an intent from extras
- This exported activity starts another activity using that received intent
- Attacker sends malicious intent inside the extras
- Exported activity forwards it to non-exported activity
- Attacker accesses private activity through public activity


```
+------------------+          +---------------------+          +---------------------+
|   Attacker App   |  ------> | Exported            |  ------> | Non-Exported        |
|                  |          | ProxyActivity       |          | AdminActivity       |
| Sends intent     |          | (Public)            |          | (Private)           |
| containing       |          |                     |          |                     |
| another intent   |          | Forwards the        |          | Opens because       |
| for AdminActivity|          | received intent     |          | request came from   |
+------------------+          +---------------------+          | same app            |
                                                               +---------------------+

Attacker accesses AdminActivity through ProxyActivity.
```

## Android app has two activities:
### Exported vs Non-Exported

#### ProxyActivity - Exported (anyone can access)

```
<activity 
    android:name=".ProxyActivity"
    android:exported="true">
</activity>
```

**exported="true"**
Other apps can send intents to this component.

```
<activity android:name=".PublicActivity"
          android:exported="true">
```

Any app on the device can start this activity. This is an attack surface.

#### AdminActivity - Not Exported (only app itself can access)
```
<activity 
    android:name=".AdminActivity"
    android:exported="false">
</activity>
```

**exported="false"**
Only the same app can send intents to this component.

```
<activity android:name=".PrivateActivity"
          android:exported="false">
```

Other apps cannot start this activity. This is secure.

==If a component has intent-filter and targets SDK below 31, it becomes exported by default even without specifying. This catches many developers off guard.==

### ProxyActivity code is vulnerable:
```java
public class ProxyActivity extends Activity {
    
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // Step 1: Gets intent from extras
        Intent nextIntent = getIntent().getParcelableExtra("next_intent");
        
        // Step 2: Starts activity using that intent (NO VALIDATION)
        if (nextIntent != null) {
            startActivity(nextIntent);
        }
        
        finish();
    }
}
```

The problem is ProxyActivity blindly trusts whatever intent it receives and forwards it.

# Web view
**Inbuilt Web engine, Native Browser**

WebView is an Android component that displays web pages inside an app. Instead of opening Chrome or another browser, the app shows the webpage within itself.

Ex:
```
WebView webView = findViewById(R.id.webview);
webView.loadUrl("https://example.com");
```

Many apps use WebView for:
- Displaying terms and conditions
- Showing payment pages
- Loading advertisements
- Hybrid apps that run web code
- OAuth login pages
- In-app browsers


**WebView runs inside the app with the app's permissions. If attacker controls what loads in WebView:**

- JavaScript runs with app context
- Can access app's local files
- Can steal cookies and tokens
- Can call Java methods if JavaScript interface exists
- Can perform phishing attacks
- User trusts the content because it is inside the app


**Flow With Vulnerability:**
```
App receives URL from intent
        |
        v
No validation of URL
        |
        v
WebView loads attacker URL
        |
        v
Attacker JavaScript executes
        |
        v
Steals data or performs actions
```


## Weak URL Redirection(BeetleBug)
Weak URL Redirection occurs when an app accepts a URL from external input and redirects to it without proper validation. 

In Android, this typically happens when:
1. Activity receives URL from intent
2. App does not validate the URL
3. App opens the URL in WebView or browser
4. Attacker can redirect user to malicious website

#### 1. Check AndroidManifest.xml of Beetlebug
Look for exported activities with intent filters:
```
<activity 
    android:name="com.beetlebug.WebViewActivity"
    android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.VIEW"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="android.intent.category.BROWSABLE"/>
        <data android:scheme="beetlebug" android:host="redirect"/>
    </intent-filter>
</activity>
```

This tells us:
- Activity is exported (accessible to other apps)
- Has BROWSABLE category (can be triggered from browser)
- Uses custom scheme: beetlebug://redirect

#### 2.Analyze the Activity Code
Open the Java source in jadx:
```java
public class WebViewActivity extends AppCompatActivity {
    
    private WebView webView;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_webview);
        
        webView = findViewById(R.id.webview);
        webView.getSettings().setJavaScriptEnabled(true);
        
        // Gets URL from intent data
        Uri uri = getIntent().getData();
        
        if (uri != null) {
            String url = uri.getQueryParameter("url");
            
            // No validation - loads any URL
            if (url != null) {
                webView.loadUrl(url);
            }
        }
    }
}
```

#### 3: Find URL Parameter
```
app.beetlebug.ctf.VulnerableWebView
```

#### 4:Exploiting the Vulnerability
Using ADB
```
 am start -n app.beetlebug/.ctf.VulnerableWebView --es "reg_url" "https://www.google.com" 
```

If It's Load the url we can do multiple exploits:-
1. Load Attacker Website
2. JavaScript Execution
3. Local File Access
4. Phishing Attack
5. Cookie Stealing
6. Attack via Browser Link
7. Attack via QR Code


