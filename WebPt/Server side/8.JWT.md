# JSON
JSON (JavaScript Object Notation) is a lightweight data format used to store and transfer data.
```json
{
  "name": "John",
  "age": 25,
  "role": "admin"
}
```

# JWT
JWT (JSON Web Token) is a token format used for authentication and secure data exchange.

## Structure of JWT:
A JWT has 3 parts separated by dots (.)
```
HEADER.PAYLOAD.SIGNATURE
```

```
eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiam9obiJ9.abc123signature
```

- **Header:**	Algorithm & token type
- **Payload:**	User data (claims)
- **Signature:**	Verifies token integrity

### working
```
User Login
    ↓
Server creates JWT
    ↓
Sends JWT to User
    ↓
User sends JWT with every request
    ↓
Server verifies JWT
```

## 1. HEADER
The header contains metadata about the token.
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

- **alg:**	Algorithm used for signing (HS256, RS256, none)
- **typ:**	Type of token

#### common algorithms:
```
Symmetric:   HS256, HS384, HS512  (same key for sign & verify)
Asymmetric:  RS256, ES256        (private key signs, public key verifies)
```


## 2. PAYLOAD
Contains the actual data you want to transmit.

```json
{
  "sub": "1234567890",
  "name": "John",
  "role": "admin",
  "iat": 1716239022,
  "exp": 1716242622
}
```

- **iss** - Issuer (who created token)
- **sub** - Subject (user ID)
- **exp** - Expiration time
- **iat** - Issued at time
- **aud** - Audience (intended recipient)

## 3. SIGNATURE

This protects the token from tampering(Data alteration).

### How Signature is Created:
```
SIGNATURE = Algorithm(
    Base64(Header) + "." + Base64(Payload),
    SECRET_KEY
)
```


## Complete JWT Creation Flow:
```
Step 1: Create Header JSON       →  Base64 Encode  →  eyJhbGciOiJIUzI1NiJ9
Step 2: Create Payload JSON      →  Base64 Encode  →  eyJ1c2VyIjoiam9obiJ9  
Step 3: Create Signature         →  Base64 Encode  →  SflKxwRJSMeKKF2QT4fw

Final JWT:
eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiam9obiJ9.SflKxwRJSMeKKF2QT4fw
```

### How Server Verifies JWT:
```
1. Split token into 3 parts
2. Decode Header & Payload (Base64)
3. Recreate signature using secret key
4. Compare with received signature
5. Check expiration (exp claim)

Match?  →  Token is VALID
No Match?  →  Token is TAMPERED/INVALID
```

==Payload is NOT encrypted - it's only Base64 encoded!==
==Anyone can decode and read it. Never store sensitive data like passwords.==

# JWT Vulnerabilities
```
┌────────────────────────────────────────────────────┐
│              JWT ATTACK SURFACE                    │
├────────────────────────────────────────────────────┤
│  1. None Algorithm Attack                          │
│  2. Algorithm Confusion (RS256 → HS256)            │
│  3. Weak Secret Key (Brute Force)                  │
│  4. Missing Signature Verification                 │
│  5. Token Expiration Issues                        │
│  6. JWK Header Injection                           │
│  7. KID Parameter Injection                        │
└────────────────────────────────────────────────────┘
```

## 1: None Algorithm Attack
Server trusts the "alg" field in header. Attacker sets it to "none" (no signature needed).

**Original Token:**
```json
Header: {"alg": "HS256", "typ": "JWT"}
Payload: {"user": "john", "role": "user"}
Signature: abc123xyz
```


**Malicious Token:**
```json
Header: {"alg": "none", "typ": "JWT"}
Payload: {"user": "john", "role": "admin"}
Signature: (empty)
```

1. Decode the token
2. Change "alg" to "none"
3. Modify payload (e.g., role: admin)
4. Remove signature
5. Send: header.payload.
                       ↑
               (empty signature, but keep the dot)


##  2: Algorithm Confusion Attack

Server expects: RS256 (asymmetric)
Attacker sends: HS256 (symmetric)

Server's PUBLIC key is known
Attacker signs token with PUBLIC key using HS256
Server verifies using same PUBLIC key
TOKEN ACCEPTED! ✓

```
Normal Flow (RS256):
┌──────────────┐                    ┌──────────────┐
│ PRIVATE KEY  │ ──── signs ────→   │ PUBLIC KEY   │ verifies
└──────────────┘                    └──────────────┘

Attack Flow (Algorithm Confusion):
┌──────────────┐                    ┌──────────────┐
│ PUBLIC KEY   │ ──── signs ────→   │ PUBLIC KEY   │ verifies
└──────────────┘                    └──────────────┘
     (attacker uses                     (server uses
      HS256 signing)                    same key to verify)
```

## 3: Weak Secret Key
If secret key is weak or common, attacker can brute-force it.
**Weak Secrets:**
- secret
- password123
- company_name
- qwerty
  
1. Capture a valid JWT
2. Use wordlist to try different secrets
3. For each secret, generate signature
4. Compare with original signature
5. Match found = Secret cracked!


**example:**
```
Token: eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiam9obiJ9.XXXX

Trying: "secret"     → Signature doesn't match
Trying: "password"   → Signature doesn't match  
Trying: "jwt123"     → SIGNATURE MATCHES! ✓

Secret Found: jwt123
```

## 4: Missing Signature Verification
Server doesn't verify the signature at all. Just decodes and trusts payload.
```python
# VULNERABLE CODE
def verify_token(token):
    payload = base64_decode(token.split('.')[1])
    return payload  # No signature check!

# SECURE CODE
def verify_token(token):
    payload = jwt.decode(token, SECRET, algorithms=['HS256'])
    return payload  # Signature verified!
```

##  5: Expiration Issues
**Issue**	                                                **Description**
No exp claim	                                    Token never expires
Long expiration                                	Token valid for days/months
exp not validated	                             Server ignores expiration

**example:**
Stolen token with no expiration
       ↓
Works forever until secret changes
       ↓
Permanent unauthorized access


## 6: JWK Header Injection
JWT allows embedding public key in header using "jwk" parameter.
Attacker manipulates JWT header parameters to trick server into using attacker-controlled keys for verification.

 ### JWK Parameter Injection
 **JWK (JSON Web Key)** = A JSON format to represent cryptographic keys.
 
```json
{
  "kty": "RSA",
  "n": "0vx7agoebGcQSuuPiLJXZpt...",
  "e": "AQAB",
  "kid": "key-id-123"
}
```

| Field | Meaning                 |
| ----- | ----------------------- |
| kty   | Key Type (RSA, EC, oct) |
| n     | RSA Modulus             |
| e     | RSA Exponent            |
| kid   | Key Identifier          |

####  JWK Injection Working
**Normal Flow:**
```
┌──────────┐         ┌──────────┐
│  Client  │         │  Server  │
└────┬─────┘         └────┬─────┘
     │                    │
     │   Send JWT         │
     │ ─────────────────→ │
     │                    │
     │     Server uses    │
     │     its OWN key    │
     │     to verify      │
     │                    │
```



**Attack Flow:**
```
┌──────────┐         ┌──────────┐
│ Attacker │         │  Server  │
└────┬─────┘         └────┬─────┘
     │                    │
     │  JWT with          │
     │  embedded JWK      │
     │ ─────────────────→ │
     │                    │
     │    Server uses     │
     │    ATTACKER's key  │
     │    from header     │
     │    to verify!      │
     │                    │
```

#### How Server process:
Server reads JWT
       ↓
Extracts JWK from header
       ↓
Uses ATTACKER's public key to verify
       ↓
Signature matches (attacker signed with matching private key)
       ↓
ACCESS GRANTED!
## 7: KID Parameter Injection
Key ID - tells server which key to use for verification.

```json
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "key1"
}
```

#### Attack Types

```
Path Traversal       =      	"kid": "../../etc/passwd"
SQL Injection        =        	"kid": "key1' OR '1'='1"
Command Injection    = 	        `"kid": "key1
```
### Path Traversal Example:
```json
{
  "alg": "HS256",
  "kid": "../../../dev/null"
}
```

**/dev/null** = empty file
Server uses empty string as secret
Attacker signs with empty secret
TOKEN ACCEPTED!


## Impact 
| Impact Category       | Severity | Description                             |
| --------------------- | -------- | --------------------------------------- |
| Authentication Bypass | Critical | Attacker can forge valid tokens         |
| Privilege Escalation  | Critical | Escalate from user to admin role        |
| Account Takeover      | Critical | Access any user account                 |
| Data Breach           | High     | Access sensitive user/system data       |
| Session Hijacking     | High     | Impersonate legitimate users            |
| Lateral Movement      | High     | Move across systems using forged tokens |
| Compliance Violation  | Medium   | GDPR, HIPAA, PCI-DSS violations         |
| Reputation Damage     | Medium   | Loss of customer trust                  |
## Mitigation
1. Never Trust Header-Embedded Keys

| Do NOT Trust    | Why                                        |
| --------------- | ------------------------------------------ |
| jwk in header   | Attacker can embed their own public key    |
| jku URL         | Attacker can point to malicious key server |
| x5c certificate | Attacker can embed self-signed certificate |
| x5u URL         | Attacker can host malicious certificate    |
2. Whitelist Algorithms

| Configuration         | Status  | Reason                       |
| --------------------- | ------- | ---------------------------- |
| Allow "none"          | ❌ Block | Allows unsigned tokens       |
| Allow HS256 + RS256   | ❌ Block | Algorithm confusion possible |
| Single algorithm only | ✅ Allow | Prevents algorithm switching |
| Explicit algorithm    | ✅ Allow | Don't trust alg header       |

3. Validate JKU/X5U URLs
   
| Validation Check  | Implementation                         |
| ----------------- | -------------------------------------- |
| URL Whitelist     | Only allow specific trusted domains    |
| HTTPS Only        | Reject HTTP URLs                       |
| No Internal IPs   | Block 127.0.0.1, 10.x.x.x, 192.168.x.x |
| No Localhost      | Block localhost references             |
| Domain Validation | Match against company domains only     |

4. Use Strong Secret Keys

| Requirement    | Minimum Standard                          |
| -------------- | ----------------------------------------- |
| Key Length     | 256 bits (32 bytes) minimum               |
| Randomness     | Cryptographically secure random generator |
| Storage        | Environment variables or secret manager   |
| Rotation       | Regular key rotation policy               |
| Never Hardcode | Never store keys in source code           |
5.  Sanitize KID Parameter

| Attack Type       | Mitigation                       |
| ----------------- | -------------------------------- |
| Path Traversal    | Whitelist allowed KID values     |
| SQL Injection     | Use parameterized queries        |
| Command Injection | Never pass KID to shell commands |
| LDAP Injection    | Sanitize special LDAP characters |
6. Security Headers & Additional Controls

| Control              | Implementation                       |
| -------------------- | ------------------------------------ |
| Token Binding        | Bind token to client fingerprint/IP  |
| Token Revocation     | Maintain blacklist of revoked tokens |
| Rate Limiting        | Limit token verification attempts    |
| Logging & Monitoring | Log all authentication failures      |
| Secure Transmission  | HTTPS only, Secure cookie flag       |